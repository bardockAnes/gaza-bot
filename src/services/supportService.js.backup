/**
 * @file supportService.js
 * @description Service for Gaza Support automation
 */

const fs = require('fs-extra');
const path = require('path');
const menu = require('../ui/menu');
const browserService = require('./browser');
const os = require('os');

/**
 * Support service for Gaza YouTube channel support
 */
class SupportService {
  constructor() {
    this.browser = browserService;
    this.menu = menu;
    this.channelsPath = path.resolve(__dirname, '../data/gazaSupport/channels.json');
    this.commentsPath = path.resolve(__dirname, '../data/gazaSupport/comments.json');
    this.settingsPath = path.resolve(__dirname, '../data/gazaSupport/settings.json');
    this.reportsDir = path.resolve(__dirname, '../data/gazaSupport/reports');
    this.sessionPath = path.resolve(__dirname, '../data/gazaSupport/session.json');
    this.currentReport = null;
  }
  
  /**
   * Get input with timeout functionality - auto-continues with default value if no input
   * @param {string} promptText - Text to display as prompt
   * @param {number} timeoutSeconds - Seconds to wait before using default
   * @param {string} defaultValue - Default value to use if timeout
   * @returns {Promise<string>} User input or default value after timeout
   * @private
   */
  async _getInputWithTimeout(promptText, timeoutSeconds = 10, defaultValue = 'y') {
    return new Promise((resolve) => {
      // Create a timeout to auto-continue
      const timeout = setTimeout(() => {
        console.log(`[No response in ${timeoutSeconds}s, auto-continuing with '${defaultValue}']`);
        resolve(defaultValue);
      }, timeoutSeconds * 1000);
      
      // Get user input
      this.menu.getInput(`${promptText} [${timeoutSeconds}s timeout]`).then(answer => {
        // Clear timeout since user responded
        clearTimeout(timeout);
        
        // Handle empty input by returning default value
        const trimmedAnswer = answer.trim();
        resolve(trimmedAnswer === '' || trimmedAnswer === 'EMPTY_INPUT' ? defaultValue : trimmedAnswer);
      });
    });
  }
  
  /**
   * Start supporting channels
   */
  /**
   * Load session data to continue from where it left off
   * @returns {Promise<Object>} Session data
   * @private
   */
  async _loadSessionData() {
    try {
      if (await fs.pathExists(this.sessionPath)) {
        const session = await fs.readJson(this.sessionPath);
        console.log(`\nFound previous session from ${new Date(session.timestamp).toLocaleString()}`);
        return session;
      }
    } catch (error) {
      console.error(`Error loading session data: ${error.message}`);
    }
    
    // Return default session data
    return {
      timestamp: new Date().toISOString(),
      lastProcessedChannelIndex: -1,
      lastReportPath: null
    };
  }
  
  /**
   * Save current session data
   * @param {Object} sessionData - Session data to save
   * @private
   */
  async _saveSessionData(sessionData) {
    try {
      // Update timestamp
      sessionData.timestamp = new Date().toISOString();
      await fs.writeJson(this.sessionPath, sessionData, { spaces: 2 });
    } catch (error) {
      console.error(`Error saving session data: ${error.message}`);
    }
  }
  
  /**
   * Initialize reporting system
   * @private
   */
  async _initializeReporting() {
    // Ensure reports directory exists
    await fs.ensureDir(this.reportsDir);
    
    // Create a new report file with timestamp
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const reportFileName = `report_${timestamp}.json`;
    this.currentReportPath = path.join(this.reportsDir, reportFileName);
    
    // Initialize report structure
    this.currentReport = {
      startTime: new Date().toISOString(),
      endTime: null,
      totalChannelsProcessed: 0,
      totalSuccessful: 0,
      totalFailed: 0,
      channelResults: []
    };
    
    // Save initial report
    await this._saveReport();
    console.log(`\nCreated new report: ${reportFileName}`);
  }
  
  /**
   * Save current report to file
   * @private
   */
  async _saveReport() {
    if (this.currentReport) {
      // Update end time
      this.currentReport.endTime = new Date().toISOString();
      await fs.writeJson(this.currentReportPath, this.currentReport, { spaces: 2 });
    }
  }
  
  /**
   * Log an event to current report
   * @param {string} channelName - Channel name
   * @param {string} eventType - Event type (start, comment, like, subscribe, watch, success, failure)
   * @param {Object} details - Event details
   * @private
   */
  async _logEvent(channelName, eventType, details = {}) {
    if (!this.currentReport) return;
    
    // Find the channel entry or create it
    let channelEntry = this.currentReport.channelResults.find(c => c.channelName === channelName);
    
    if (!channelEntry) {
      channelEntry = {
        channelName,
        startTime: new Date().toISOString(),
        endTime: null,
        success: false,
        events: []
      };
      this.currentReport.channelResults.push(channelEntry);
    }
    
    // Add the event
    const event = {
      timestamp: new Date().toISOString(),
      type: eventType,
      ...details
    };
    
    // Add event to channel entry
    channelEntry.events.push(event);
    channelEntry.endTime = event.timestamp;
    
    // For success/failure events, update channel status
    if (eventType === 'success') {
      channelEntry.success = true;
      this.currentReport.totalSuccessful++;
    } else if (eventType === 'failure') {
      channelEntry.success = false;
      this.currentReport.totalFailed++;
    }
    
    // Save the report after each event
    await this._saveReport();
    
    // Also log to console
    console.log(`[LOG] ${eventType.toUpperCase()}: ${channelName} - ${details.message || ''}`);
  }

  async startSupporting() {
    try {
      console.log('\nu27a1ufe0f Starting Gaza Support automation...');
      
      // Load previous session data
      const sessionData = await this._loadSessionData();
      
      // Initialize reporting system
      await this._initializeReporting();
      
      // Update session with current report path
      sessionData.lastReportPath = this.currentReportPath;
      await this._saveSessionData(sessionData);
      
      // Check if browser is initialized
      if (!this.browser.browser) {
        console.log('\n❌ Browser is not initialized! Please start the browser from the main menu first.');
        await menu.waitForEnter();
        return;
      }
      
      // Check if logged in
      if (!this.browser.isAuthenticated) {
        console.log('\n❌ You must be logged in to YouTube! Please log in from the main menu first.');
        await menu.waitForEnter();
        return;
      }
      
      // Load channels and settings (sorted by least supported first)
      const channels = await this.loadChannels(true);
      const settings = await this.loadSettings();
      const comments = await this.loadComments();
      
      if (channels.length === 0) {
        console.log('\nu274c No channels found! Please add some channels first.');
        await menu.waitForEnter();
        return;
      }
      
      if (comments.length === 0) {
        console.log('\nu274c No comments found! Please add some comments first.');
        await menu.waitForEnter();
        return;
      }
      
      console.log(`\nFound ${channels.length} channels and ${comments.length} comments.\n`);
      
      // Display channel rotation order
      console.log('Channel rotation order (prioritizing least supported):');
      channels.forEach((channel, index) => {
        console.log(`${index + 1}. ${channel.name} (previous support count: ${channel.supportCount || 0})`); 
      });
      
      console.log('Ready to start supporting channels!');
      console.log('\n=== Support Settings ===');
      console.log(`Watch time: ${settings.watchTimePercentage}% of video`);
      console.log(`Min watch time: ${settings.minWatchTimeSeconds} seconds`);
      console.log(`Max watch time: ${settings.maxWatchTimeSeconds} seconds`);
      console.log(`Like videos: ${settings.likeVideos ? 'Yes' : 'No'}`);
      console.log(`Subscribe to channels: ${settings.subscribeToChannels ? 'Yes' : 'No'}`);
      console.log(`Pause between channels: ${settings.pauseBetweenChannelsSeconds} seconds`);
      
      // Get confirmation with 10 second timeout, default to 'y'
      const confirm = await this._getInputWithTimeout('Start supporting now? (y/n)', 10, 'y');
      
      if (confirm.toLowerCase() !== 'y') {
        console.log('\nu274c Support cancelled.');
        await menu.waitForEnter();
        return;
      }
      
      // Start supporting channels
      let supportCount = 0;
      let startIndex = 0;
      
      // Ask if user wants to continue from last session
      if (sessionData.lastProcessedChannelIndex >= 0 && sessionData.lastProcessedChannelIndex < channels.length - 1) {
        console.log(`\nPrevious session stopped at channel #${sessionData.lastProcessedChannelIndex + 1} (${channels[sessionData.lastProcessedChannelIndex].name})`);
        const continueFromLast = await this._getInputWithTimeout('Continue from where you left off? (y/n)', 10, 'y');
        
        if (continueFromLast.toLowerCase() === 'y') {
          startIndex = sessionData.lastProcessedChannelIndex + 1;
          console.log(`\nContinuing from channel #${startIndex + 1} (${channels[startIndex].name})`);
        }
      }
      
      for (let i = startIndex; i < channels.length; i++) {
        const channel = channels[i];
        
        // Update session data with current channel index
        sessionData.lastProcessedChannelIndex = i;
        await this._saveSessionData(sessionData);
        // Log start of channel support
        await this._logEvent(channel.name, 'start', { url: channel.url, previousCount: channel.supportCount || 0 });
        // Show current channel
        console.clear();
        console.log(`\nu27a1ufe0f Supporting channel: ${channel.name}`);
        console.log(`Channel URL: ${channel.url}`);
        console.log(`Previous support count: ${channel.supportCount || 0}`);
        
        // Navigate to channel
        const success = await this.supportChannel(channel, settings, comments);
        
        if (success) {
          // Update channel support count and last supported date
          channel.supportCount = (channel.supportCount || 0) + 1;
          channel.lastSupported = new Date().toISOString();
          supportCount++;
          
          // Save updated channel data
          await this.saveChannels(channels);
          
          console.log(`\nu2705 Successfully supported ${channel.name}!`);
          
          // Log success in report
          await this._logEvent(channel.name, 'success', { message: 'Channel supported successfully' });
        } else {
          console.log(`\nu274c Failed to support ${channel.name}.`);
          
          // Log failure in report
          await this._logEvent(channel.name, 'failure', { message: 'Failed to support channel' });
        }
        
        // Update session data after each channel
        await this._saveSessionData(sessionData);
        
        // Ask to continue or exit with 10 second timeout, default to 'y'
        const continueSupport = await this._getInputWithTimeout('Continue to next channel? (y/n)', 10, 'y');
        
        if (continueSupport.toLowerCase() !== 'y') {
          console.log('\nu274c Support process stopped by user.');
          break;
        }
        console.log('\u27a1 Continuing to next channel...');
        
        // Pause between channels
        console.log(`\nPausing for ${settings.pauseBetweenChannelsSeconds} seconds before next channel...`);
        await this.sleep(settings.pauseBetweenChannelsSeconds * 1000);
      }
      
      // Reset session data since we've completed the full list
      sessionData.lastProcessedChannelIndex = -1;
      await this._saveSessionData(sessionData);
      
      // Update final report statistics
      this.currentReport.totalChannelsProcessed = channels.length;
      await this._saveReport();
      
      console.log(`\nu2705 Support process complete! Supported ${supportCount} channels.`);
      console.log(`Report saved to: ${this.currentReportPath}`);
      
      // Ask user if they want to restart the support process
      const restartSupport = await this._getInputWithTimeout('Restart support process? (y/n)', 10, 'y');
      
      if (restartSupport.toLowerCase() === 'y') {
        console.log('\nu27a1 Restarting Gaza support process...');
        // Call this method again to restart the entire process
        return this.startSupporting();
      }
      
      console.log('\u2705 Returning to menu...');
    } catch (error) {
      console.error(`\nu274c Error during support process: ${error.message}`);
      
      // Ask user if they want to restart despite the error
      const restartAfterError = await this._getInputWithTimeout('Try again? (y/n)', 10, 'y');
      
      if (restartAfterError.toLowerCase() === 'y') {
        console.log('\u27a1 Restarting Gaza support process...');
        // Call this method again to restart the entire process
        return this.startSupporting();
      }
      
      console.log('\u2705 Returning to menu...');
    }
  }
  
  /**
   * Support a single channel
   * @param {Object} channel - Channel to support
   * @param {Object} settings - Support settings
   * @param {Array<string>} comments - Array of comments
   * @returns {Promise<boolean>} Success status
   */
  async supportChannel(channel, settings, comments) {
    try {
      // Create object to track all actions on this channel
      const supportActions = {
        videoFound: false,
        videoPlayed: false,
        commentPosted: false,
        commentVerified: false,
        liked: false,
        subscribed: false,
        watchTime: 0
      };
      // Access the page directly from the browser service
      const page = this.browser.page;
      
      // Make sure page exists
      if (!page) {
        console.log('\n❌ Browser page not available!');
        return false;
      }
      
      // Navigate directly to the videos page of the channel
      const videosUrl = channel.url + '/videos';
      console.log(`\nNavigating directly to videos page: ${videosUrl}`);
      await page.goto(videosUrl, { waitUntil: 'networkidle2' });
      
      // Find the latest video
      console.log('Looking for latest video...');
      
      // Wait for videos to load
      console.log('Waiting for page to fully load...');
      await this.sleep(5000);
      
      // Find video URL using a simplified approach
      console.log('Finding the latest video...');
      const videoUrl = await page.evaluate(() => {
        // Try to find a video thumbnail from rich item renderer (new YouTube UI)
        const thumbnails = document.querySelectorAll('ytd-rich-item-renderer a#thumbnail[href*="/watch"]');
        if (thumbnails && thumbnails.length > 0) {
          return thumbnails[0].href;
        }
        
        // Fallback to any video link
        const videoLinks = Array.from(document.querySelectorAll('a[href*="/watch"]'))
          .filter(link => link.href.includes('youtube.com/watch?v='));
          
        return videoLinks.length > 0 ? videoLinks[0].href : null;
      });
      
      // Check if we found a video
      if (!videoUrl) {
        console.log('Failed to find any videos on this channel.');
        return false;
      }
      
      supportActions.videoFound = true;
      
      console.log('Found video URL: ' + videoUrl);
      const latestVideo = { href: videoUrl, title: 'Latest video' };
      
      // Navigate to the video with a longer timeout
      console.log('Navigating to video...');
      await page.goto(latestVideo.href, { waitUntil: 'networkidle2', timeout: 60000 });
      
      // Check for and skip ads
      console.log('Checking for ads...');
      await this.skipAdsIfPresent(page);
      
      // Get video details and calculate watch time
      console.log('Getting video details...');
      const videoDetails = await this.getVideoDetails(page);
      console.log(`Video duration: ${videoDetails.durationText} (${videoDetails.durationSeconds} seconds)`);
      
      // Calculate watch time based on settings and actual duration
      const watchTimePercentage = settings.watchTimePercentage / 100;
      let targetWatchTime = Math.floor(videoDetails.durationSeconds * watchTimePercentage);
      
      // Apply min/max boundaries from settings
      targetWatchTime = Math.max(
        Math.min(settings.minWatchTimeSeconds, videoDetails.durationSeconds), // Don't watch longer than the video if it's shorter than min
        Math.min(targetWatchTime, settings.maxWatchTimeSeconds) // Don't exceed max watch time
      );
      
      console.log(`Will watch for ${targetWatchTime} seconds (${Math.floor(targetWatchTime/videoDetails.durationSeconds * 100)}% of video)`);
      
      // First make sure video is at the beginning
      console.log('Ensuring video starts from the beginning...');
      await page.evaluate(() => {
        // Get the video element
        const video = document.querySelector('video.html5-main-video');
        if (video) {
          // Force seek to the beginning
          video.currentTime = 0;
          // Try to play the video
          if (video.paused) {
            video.play().catch(() => console.log('Could not autoplay video'));
          }
        }
      });
      await this.sleep(1000);
      
      // Check if we're at the beginning of the video
      const videoPosition = await page.evaluate(() => {
        const video = document.querySelector('video.html5-main-video');
        return video ? video.currentTime : 0;
      });
      console.log(`Current video position: ${videoPosition} seconds`);
{{ ... }}
          }
        });
        await this.sleep(1000);
      }
      
      supportActions.videoPlayed = true;
      
      // Log video details to report
      await this._logEvent(channel.name, 'video', {
        title: videoDetails.title,
        duration: videoDetails.durationSeconds,
        durationText: videoDetails.durationText,
        url: videoUrl,
        targetWatchTime: targetWatchTime
      });
      
      // Subscribe to the channel if enabled (do this first, most important)
      if (settings.subscribeToChannels) {
        console.log('Subscribing to the channel...');
        try {
          // Much more robust subscribe method
{{ ... }}
      // Leave a comment early in the process
      console.log('Leaving a comment early...');
      const commentResult = await this.leaveComment(page, comments, channel.name);
      console.log(`Comment result: ${commentResult.success ? 'Success' : 'Failed'} ${commentResult.verified ? '(Verified)' : ''}`);
      
      // Update comment tracking
      supportActions.commentPosted = commentResult.success;
      supportActions.commentVerified = commentResult.verified || false;
      
      // Like the video if enabled (do this early too)
      if (settings.likeVideos) {
        console.log('Liking the video...');
        try {
          // Make sure we're at the right position to see the video controls
          await page.evaluate(() => {
            // Scroll to position where like button should be visible but not into comments
            window.scrollTo(0, 200);
          });
          
          // Wait for the like button to appear, using the specific selectors you requested
          await page.waitForSelector('button[title="I like this"], button[aria-label^="like this video"], button[aria-label^="Like"], ytd-toggle-button-renderer[aria-label^="Like"]', 
            { visible: true, timeout: 5000 }).catch(() => {});
            
          // Small delay for UI to stabilize
          await this.sleep(1000);
          
          // Check if already liked and click only if not already liked
          const likingResult = await page.evaluate(() => {
            // Try multiple selectors focused on exact attributes
            const likeButtonSelectors = [
              'button[title="I like this"]',
              'button[aria-label^="like this video"]',
              'button[aria-label^="Like"]',
              'ytd-toggle-button-renderer[aria-label^="Like"]',
              '#top-level-buttons-computed ytd-toggle-button-renderer:first-child button'
            ];
            
            for (const selector of likeButtonSelectors) {
              const buttons = document.querySelectorAll(selector);
              for (const button of buttons) {
                // Critical: Check if button is already pressed/liked
                const isAlreadyLiked = button.getAttribute('aria-pressed') === 'true';
                const isVisible = button.offsetWidth > 0 && button.offsetHeight > 0;
                
                if (isVisible && !isAlreadyLiked) {
                  // Only click if not already liked
                  try {
                    button.click();
                    return { success: true, message: `Clicked ${selector}` };
                  } catch (e) {
                    // Continue to next button if this one fails
                  }
                } else if (isVisible && isAlreadyLiked) {
                  return { success: true, message: 'Video is already liked' };
                }
              }
            }
            return { success: false, message: 'No suitable like button found' };
          });
          
          console.log(likingResult.message);
          
          if (likingResult.success) {
            supportActions.liked = true;
            await this._logEvent(channel.name, 'like', { success: true });
          } else {
            await this._logEvent(channel.name, 'like', { success: false, message: likingResult.message });
          }
{{ ... }}
      
          const likeButton = await page.$('button[aria-label^="Like"][aria-pressed="false"]');
          
          if (likeButton) {
            await likeButton.click();
            console.log('Successfully liked the video!');
            console.log('Like button not found or already pressed, trying fallback...');
      
            const subscribed = await page.evaluate(() => {
            // Try multiple selector approaches
            const selectors = [
              'button[aria-label*="Subscribe"]',
              'yt-button-renderer[aria-label*="Subscribe"]',
              'ytd-subscribe-button-renderer',
              '#subscribe-button' // Common container ID
            ];
            
            for (const selector of selectors) {
              const elements = document.querySelectorAll(selector);
              for (const element of elements) {
                if (element && element.offsetParent !== null) {
                  try {
                    // Trigger click event
                    element.click();
                    return true;
                  } catch (e) {
                    console.log('Failed to click, trying another element');
                  }
                }
              }
            }
            return false;
          });
          
          if (subscribed) {
            console.log('Successfully subscribed to channel!');
            supportActions.subscribed = true;
            await this._logEvent(channel.name, 'subscribe', { success: true });
          } else {
            console.log('Could not find subscribe button, might already be subscribed');
            await this._logEvent(channel.name, 'subscribe', { success: false, reason: 'Button not found or already subscribed' });
          }          }
                  }
                }
              }
              return false;
            });
{{ ... }}
      
            console.log(liked ? 'Successfully liked the video (fallback).' : 'Like button not clickable or already liked.');
            
            if (liked) {
              supportActions.liked = true;
              await this._logEvent(channel.name, 'like', { success: true, method: 'fallback' });
            } else {
              await this._logEvent(channel.name, 'like', { success: false, message: 'Button not clickable or already liked' });
            }
          }
        } catch (error) {
          console.log(`Like error: ${error.message}`);
        }
      }
      
      // Now start watching the video (scroll back up)
      console.log('Scrolling back to video and starting watch timer...');
      await page.evaluate(() => {
        // Scroll back to top to watch video
        window.scrollTo(0, 0);
        
        // Ensure video is playing from beginning
        const video = document.querySelector('video.html5-main-video');
        if (video) {
          // Force seek to the beginning again
          video.currentTime = 0;
          // Try to play if paused
          if (video.paused) {
            video.play().catch(() => {});
          }
        }
      });
      
      // Store initial video information for comparison
      const initialVideoId = await page.evaluate(() => {
        // Extract video ID from URL or player data
        const url = window.location.href;
        const match = url.match(/(?:v=|\/)([0-9A-Za-z_-]{11})(?:[\?&]|$)/);
        return match ? match[1] : '';
      });
      
      console.log(`Started watching video with ID: ${initialVideoId}...`);
      
      // Start watching the video with better progress tracking
      const startTime = Date.now();
      const checkInterval = 10; // Check progress every 10 seconds
      let elapsedSeconds = 0;
      
      // Watch until target time is reached
      while (elapsedSeconds < targetWatchTime) {
        // Wait for specified interval
        await this.sleep(checkInterval * 1000);
        
        // Check video state: current position, duration, and if it has ended
        const videoState = await page.evaluate(() => {
          const video = document.querySelector('video.html5-main-video');
          if (!video) return { error: 'Video element not found' };
          
          // Get video metadata
          const currentTime = video.currentTime;
          const duration = video.duration;
          const hasEnded = video.ended;
          const isPaused = video.paused;
          
          // Check if we're at the end of the video
          const isNearEnd = duration > 0 && (currentTime >= duration - 5);
          
          // Get current video ID
          const url = window.location.href;
          const match = url.match(/(?:v=|\/)([0-9A-Za-z_-]{11})(?:[\?&]|$)/);
          const videoId = match ? match[1] : '';
          
          return {
            videoId,
            currentTime,
            duration,
            hasEnded,
            isPaused,
            isNearEnd
          };
        });
        
        // Log current video position for debugging
        console.log(`Video position: ${Math.floor(videoState.currentTime)}/${Math.floor(videoState.duration)} seconds`);
        
        // Check if video ID changed (autoplay to next video)
        if (videoState.videoId !== initialVideoId && initialVideoId !== '') {
          console.log(`Video changed from ${initialVideoId} to ${videoState.videoId}. Ending watch session.`);
          break;
        }
        
        // Check if video has ended or is very close to ending
        if (videoState.hasEnded || videoState.isNearEnd) {
          console.log('Video has ended or is near the end. Stopping watch timer.');
          break;
        }
        
        // If video is paused, try to resume playback
        if (videoState.isPaused) {
          console.log('Video is paused. Attempting to resume...');
          await page.evaluate(() => {
            const video = document.querySelector('video.html5-main-video');
            if (video && video.paused) {
              video.play().catch(() => console.log('Could not resume video'));
            }
          });
        }
        
        // Skip ads if they appear during playback
        await this.skipAdsIfPresent(page);
        
        // Update elapsed time
        elapsedSeconds += checkInterval;
        console.log(`Watched ${elapsedSeconds}/${targetWatchTime} seconds (${Math.floor(elapsedSeconds/targetWatchTime * 100)}% complete)`);
      }
      
      console.log('Finished watching video!');
      
      // Update the final watch time
      supportActions.watchTime = elapsedSeconds;
      
      // Log support action summary to report
      await this._logEvent(channel.name, 'summary', supportActions);
      
      // Return detailed success information to help with troubleshooting
      console.log('\n=== Support Actions Summary ===');
      console.log(`Video found: ${supportActions.videoFound ? 'Yes' : 'No'}`);
      console.log(`Video played: ${supportActions.videoPlayed ? 'Yes' : 'No'}`);
      console.log(`Comment posted: ${supportActions.commentPosted ? 'Yes' : 'No'}`);
      console.log(`Comment verified: ${supportActions.commentVerified ? 'Yes' : 'No'}`);
      console.log(`Liked video: ${supportActions.liked ? 'Yes' : 'No'}`);
      console.log(`Subscribed: ${supportActions.subscribed ? 'Yes' : 'No'}`);
      console.log(`Watch time: ${supportActions.watchTime} seconds`);
      
      return true;
    } catch (error) {
      console.error(`Error supporting channel: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Get detailed information about the current video
   * @param {Object} page - Browser page
   * @returns {Promise<Object>} Video details including duration and title
   */
  async getVideoDetails(page) {
    try {
      // Wait for the video player to load fully
      console.log('Waiting for video player elements to load...');
      
      // Wait for critical video elements with expanded timeout
      const selectors = [
        '.ytp-time-duration',                  // Duration display in player
        'h1.ytd-video-primary-info-renderer',  // Video title
        'video.html5-main-video'               // Actual video element
      ];
      
      // Wait for at least one of these elements to be available
      for (const selector of selectors) {
        try {
          await page.waitForSelector(selector, { timeout: 3000, visible: true });
          break; // Break once we find at least one element
        } catch (err) {
          // Continue trying other selectors
        }
      }
      
      // Extract video details with a simplified, more reliable approach
      const videoDetails = await page.evaluate(() => {
        // Initialize with default values
        const details = {
          title: 'Unknown Video',
          durationText: '0:00',
          durationSeconds: 300, // Default 5 minutes
          isLive: false
        };
        
        // 1. Get video title
        const titleElement = document.querySelector('h1.ytd-video-primary-info-renderer, .title.ytd-video-primary-info-renderer');
        if (titleElement) {
          details.title = titleElement.textContent.trim();
        }
        
        // 2. First check if this is a live stream (most important to detect)
        let isLiveStream = false;
        
        // Check for live badge (red dot)
        const liveBadge = document.querySelector('.ytp-live-badge');
        if (liveBadge && liveBadge.offsetParent !== null) {
          isLiveStream = true;
        }
        
        // Double-check with another strong indicator
        const liveText = document.querySelector('.ytp-live');
        if (liveText && liveText.offsetParent !== null) {
          isLiveStream = true;
        }
        
        // If both indicators agree it's live, mark as live stream
        if (isLiveStream) {
          console.log('Confirmed live stream detection');
          details.isLive = true;
          details.durationText = 'LIVE';
          details.durationSeconds = 300; // Default 5 minutes for live videos
          return details;
        }
        
        // 3. For regular videos, get duration (most reliable method first)
        const videoElement = document.querySelector('video.html5-main-video');
        if (videoElement && videoElement.duration && videoElement.duration > 0 && videoElement.duration < 36000) {
          // We have reliable duration from video element
          details.durationSeconds = Math.round(videoElement.duration);
          details.isLive = false; // Definitely not live
          
          // Format for display (avoiding padStart for compatibility)
          const hours = Math.floor(details.durationSeconds / 3600);
          const minutes = Math.floor((details.durationSeconds % 3600) / 60);
          const seconds = details.durationSeconds % 60;
          
          if (hours > 0) {
            details.durationText = hours + ':' + 
                               (minutes < 10 ? '0' : '') + minutes + ':' + 
                               (seconds < 10 ? '0' : '') + seconds;
          } else {
            details.durationText = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
          }
          
          console.log('Video element duration: ' + details.durationText);
        } else {
          // 4. Fallback: Get duration from the UI element
          const durationElement = document.querySelector('.ytp-time-duration');
          if (durationElement) {
            details.durationText = durationElement.textContent.trim();
            console.log('UI duration: ' + details.durationText);
            
            // Parse into seconds
            try {
              const parts = details.durationText.split(':').map(Number);
              
              if (parts.length === 3) { // HH:MM:SS
                details.durationSeconds = (parts[0] * 3600) + (parts[1] * 60) + parts[2];
              } else if (parts.length === 2) { // MM:SS
                details.durationSeconds = (parts[0] * 60) + parts[1];
              }
            } catch (e) {
              console.log('Failed to parse duration text: ' + e);
            }
          }
        }
        
        // 5. If we still don't have a duration, use default
        if (!details.durationSeconds || details.durationSeconds <= 0) {
          details.durationSeconds = 300; // Default 5 minutes
          details.durationText = '5:00';
        }
        
        return details;
      });
      
      // Additional verification and logging
      console.log(`Video title: ${videoDetails.title}`);
      console.log(`Video duration: ${videoDetails.durationText} (${videoDetails.durationSeconds} seconds)`);
      
      if (videoDetails.isLive) {
        console.log('This appears to be a live stream');
      }
      
      return videoDetails;
    } catch (error) {
      console.error(`Error getting video details: ${error.message}`);
      // Return default values as fallback
      return {
        title: 'Unknown Video',
        durationText: '5:00',
        durationSeconds: 300, // Default 5 minutes
        isLive: false
      };
    }
  }
  
  /**
   * Get video watch time based on settings (legacy method kept for compatibility)
   * @param {Object} page - Browser page
   * @param {Object} settings - Support settings
   * @returns {Promise<number>} Watch time in seconds
   */
  async getVideoWatchTime(page, settings) {
    try {
      // Use the new method to get details
      const videoDetails = await this.getVideoDetails(page);
      
      // Calculate watch time based on settings
      let watchTime = Math.floor(videoDetails.durationSeconds * settings.watchTimePercentage / 100);
      
      // Limit watch time between min and max
      watchTime = Math.max(settings.minWatchTimeSeconds, Math.min(watchTime, settings.maxWatchTimeSeconds));
      
      return watchTime;
    } catch (error) {
      console.error(`Error getting video duration: ${error.message}`);
      return settings.minWatchTimeSeconds; // Fallback to minimum watch time
    }
  }
  
  /**
   * Leave a comment on the video
   * @param {Object} page - Browser page
   * @param {Array<string>} comments - Array of comments
   * @param {string} channelName - Name of the channel being supported
   * @returns {Promise<Object>} Result with success status and details
   */
  async leaveComment(page, comments, channelName) {
    try {
      // Get a random comment
      const randomIndex = Math.floor(Math.random() * comments.length);
      const comment = comments[randomIndex];
      
      console.log(`Selected comment: ${comment}`);
      
      // Scroll down to comment section
      await page.evaluate(() => {
        window.scrollBy(0, 500);
      });
      
      await this.sleep(2000);
      
      // Find the comment input box
      const commentSelector = '#simplebox-placeholder, #commentbox'
      const commentBoxElement = await page.waitForSelector(commentSelector, { timeout: 5000 })
        .catch(() => null);
      
      if (!commentBoxElement) {
        const reason = "Could not find comment input box";
        console.log(`❌ ${reason}`);
        await this._logEvent(channelName, 'comment', {
          comment,
          success: false,
          error: reason
        });
        return { success: false, reason };
      }
      
      // Click the comment box to activate it
      await page.click(commentSelector);
      
      await this.sleep(1000);
      
      // Find the editable comment area
      const commentTextSelector = '#contenteditable-root, .commentbox-input';
      const commentTextElement = await page.waitForSelector(commentTextSelector, { timeout: 5000 })
        .catch(() => null);
      
      if (!commentTextElement) {
        const reason = "Could not find editable comment area";
        console.log(`❌ ${reason}`);
        await this._logEvent(channelName, 'comment', {
          comment,
          success: false,
          error: reason
        });
        return { success: false, reason };
      }
      
      // Type the comment
      await page.type(commentTextSelector, comment);
      
      await this.sleep(1000);
      
      // Find and click the comment submit button
      const submitButtonSelector = '#submit-button, .commentbox-submit';
      const submitButton = await page.waitForSelector(submitButtonSelector, { timeout: 5000 })
        .catch(() => null);
      
      if (!submitButton) {
        const reason = "Could not find submit button";
        console.log(`❌ ${reason}`);
        await this._logEvent(channelName, 'comment', {
          comment,
          success: false,
          error: reason
        });
        return { success: false, reason };
      }
      
      await page.click(submitButtonSelector);
      console.log('Submitted comment, verifying success...');
      
      // Wait a moment for the comment to be posted
      await this.sleep(4000);
      
      // Verify if comment was actually posted
      const wasCommentPosted = await page.evaluate((commentText) => {
        // Look for the comment text in any comment elements
        const commentElements = document.querySelectorAll('.comment-renderer-text-content, ytd-comment-renderer #content-text');
        
        for (const element of commentElements) {
          // Even partial match is good evidence
          if (element.textContent.includes(commentText.substring(0, Math.min(20, commentText.length)))) {
            return true;
          }
        }
        
        // Check for confirmation notifications
        const confirmElements = document.querySelectorAll('.ytd-comments-header-renderer');
        for (const element of confirmElements) {
          if (element.textContent.includes('Comment added') || 
              element.textContent.includes('Your comment')) {
            return true;
          }
        }
        
        return false;
      }, comment.substring(0, Math.min(20, comment.length)));
      
      if (wasCommentPosted) {
        console.log('✅ Comment verification: Comment was successfully posted!');
        await this._logEvent(channelName, 'comment', {
          comment,
          success: true,
          verified: true
        });
        return { success: true, verified: true };
      } else {
        // Check for common errors
        const errorFound = await page.evaluate(() => {
          const errorElements = document.querySelectorAll('.yt-alert-message, .ytd-alert-renderer');
          for (const element of errorElements) {
            if (element.textContent.includes('hold') || 
                element.textContent.includes('review') || 
                element.textContent.includes('error')) {
              return element.textContent.trim();
            }
          }
          return null;
        });
        
        if (errorFound) {
          console.log(`⚠️ Comment submitted but with notice: ${errorFound}`);
          await this._logEvent(channelName, 'comment', {
            comment,
            success: true, 
            verified: false,
            notice: errorFound
          });
          return { success: true, verified: false, notice: errorFound };
        } else {
          console.log('⚠️ Comment submitted but verification failed (might be under review)');
          await this._logEvent(channelName, 'comment', {
            comment,
            success: true,
            verified: false
          });
          return { success: true, verified: false };
        }
      }
    } catch (error) {
      console.error(`❌ Error leaving comment: ${error.message}`);
      
      // Log comment failure
      if (this.currentReport) {
        await this._logEvent(channelName, 'comment', {
          comment: comments[Math.floor(Math.random() * comments.length)],
          success: false,
          error: error.message
        });
      }
      
      return { success: false, error: error.message };
    }
  }
  
  /**
   * Load channels from file
   * @param {boolean} prioritizeLeastSupported - Whether to sort channels by least supported first
   * @returns {Promise<Array>} Channels array
   */
  async loadChannels(prioritizeLeastSupported = true) {
    try {
      if (!await fs.pathExists(this.channelsPath)) {
        return [];
      }
      
      const channels = await fs.readJson(this.channelsPath);
      
      // Sort channels by least supported first if requested
      if (prioritizeLeastSupported && channels.length > 0) {
        // Make a copy to avoid modifying the original data
        return [...channels].sort((a, b) => {
          // Handle undefined supportCount
          const countA = a.supportCount || 0;
          const countB = b.supportCount || 0;
          
          // If support counts are equal, compare by last supported date
          if (countA === countB) {
            // If lastSupported doesn't exist, put it first
            if (!a.lastSupported) return -1;
            if (!b.lastSupported) return 1;
            
            // Otherwise, older date first
            return new Date(a.lastSupported) - new Date(b.lastSupported);
          }
          
          // Sort by support count (ascending)
          return countA - countB;
        });
      }
      
      return channels;
    } catch (error) {
      console.error(`Error loading channels: ${error.message}`);
      return [];
    }
  }
  
  /**
   * Save channels to file
   * @param {Array} channels - Channels array
   */
  async saveChannels(channels) {
    try {
      await fs.writeJson(this.channelsPath, channels, { spaces: 2 });
    } catch (error) {
      console.error(`Error saving channels: ${error.message}`);
    }
  }
  
  /**
   * Load comments from file
   * @returns {Promise<Array>} Comments array
   */
  async loadComments() {
    try {
      if (!await fs.pathExists(this.commentsPath)) {
        return [];
      }
      
      return await fs.readJson(this.commentsPath);
    } catch (error) {
      console.error(`Error loading comments: ${error.message}`);
      return [];
    }
  }
  
  /**
   * Load settings from file
   * @returns {Promise<Object>} Settings object
   */
  async loadSettings() {
    // Default settings
    const defaultSettings = {
      watchTimePercentage: 70,
      minWatchTimeSeconds: 60,
      maxWatchTimeSeconds: 600,
      likeVideos: true,
      subscribeToChannels: true,
      pauseBetweenChannelsSeconds: 30
    };
    
    try {
      if (!await fs.pathExists(this.settingsPath)) {
        return defaultSettings;
      }
      
      return await fs.readJson(this.settingsPath);
    } catch (error) {
      console.error(`Error loading settings: ${error.message}`);
      return defaultSettings;
    }
  }
  
  /**
   * Attempt to skip ads if present, with improved detection for ad blockers
   * @param {Object} page - Browser page
   * @returns {Promise<boolean>} Whether ads were detected
   */
  async skipAdsIfPresent(page) {
    try {
      // More reliable ad detection that works with ad blockers
      const adResult = await page.evaluate(() => {
        // Multiple visual and content checks for ads
        const adIndicators = [
          // 1. Check for ad UI elements that are actually visible
          () => {
            const adTexts = document.querySelectorAll('.ytp-ad-text');
            for (const el of adTexts) {
              if (el.offsetParent !== null && el.textContent.trim().length > 0) return true;
            }
            return false;
          },
          
          // 2. Check for ad preview containers that are visible
          () => {
            const adPreviews = document.querySelectorAll('.ytp-ad-preview-container');
            for (const el of adPreviews) {
              if (el.offsetParent !== null) return true;
            }
            return false;
          },
          
          // 3. Check if the skip button is visible (clearest indicator)
          () => {
            const skipButtons = document.querySelectorAll('button.ytp-skip-ad-button, .ytp-ad-skip-button');
            for (const el of skipButtons) {
              if (el.offsetParent !== null) return true;
            }
            return false;
          },
          
          // 4. Check for specific ad text overlays
          () => {
            const adOverlays = document.querySelectorAll('.ytp-ad-text-overlay');
            for (const el of adOverlays) {
              if (el.offsetParent !== null) return true;
            }
            return false;
          },
          
          // 5. Check for ad badge (small 'Ad' text)
          () => {
            const adBadges = Array.from(document.querySelectorAll('.ytp-ad-simple-ad-badge, .ytp-ad-overlay-ad-badge'));
            for (const badge of adBadges) {
              if (badge.offsetParent !== null && badge.innerText.includes('Ad')) return true;
            }
            return false;
          },
          
          // 6. Check if we're on an in-stream ad (most reliable method)
          () => {
            const video = document.querySelector('video.html5-main-video');
            if (video && video.getAttribute('data-is-ad') === 'true') return true;
            return false;
          }
        ];
        
        // Count how many indicators detected an ad
        let adDetectionCount = 0;
        for (const detector of adIndicators) {
          if (detector()) adDetectionCount++;
        }
        
        // Only report an ad if at least 2 indicators confirm it
        // This prevents false positives with ad blockers
        const hasAd = adDetectionCount >= 2;
        
        if (!hasAd) {
          return { hasAd: false };
        }
        
        // Try to skip the ad if we're confident it's an ad
        const skipButton = document.querySelector('button.ytp-skip-ad-button, .ytp-ad-skip-button');
        if (skipButton && skipButton.offsetParent !== null) {
          try {
            skipButton.click();
            return { hasAd: true, skipped: true };
          } catch(e) {
            // Failed to click
          }
        }
        
        return { hasAd: true, skipped: false };
      });
      
      if (!adResult.hasAd) {
        // No ads detected, quietly continue without logging
        return false;
      }
      
      // If ad was detected but not skipped, wait for it
      if (adResult.hasAd && !adResult.skipped) {
        console.log('Ad detected but could not skip. Waiting 5 seconds...');
        await this.sleep(5000);
        
        // Try once more to skip
        const secondAttempt = await page.evaluate(() => {
          const skipButton = document.querySelector('button.ytp-skip-ad-button, .ytp-ad-skip-button');
          if (skipButton && skipButton.offsetParent !== null) {
            try {
              skipButton.click();
              return true;
            } catch(e) {
              // Failed to click
            }
          }
          return false;
        });
        
        if (secondAttempt) {
          console.log('Successfully skipped ad on second attempt.');
        } else {
          console.log('Ad still not skippable. Continuing with video...');
        }
      } else if (adResult.skipped) {
        console.log('Successfully skipped ad!');
      }
      
      // Wait a moment for video to start properly
      await this.sleep(1000);
      
      return true;
    } catch (error) {
      console.error(`Error skipping ads: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Sleep for specified milliseconds
   * @param {number} ms - Milliseconds to sleep
   * @returns {Promise} Sleep promise
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = new SupportService();
