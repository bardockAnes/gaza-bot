/**
 * @file helpers.js
 * @description Helper utilities for YouTube automation
 * @author Generated by Cascade
 * @created ${new Date().toISOString().split('T')[0]}
 */

const fs = require('fs-extra');
const path = require('path');
const config = require('../config');

/**
 * Generate a random delay within configured range to mimic human behavior
 * @param {number} [min=config.timing.actionDelay.min] - Minimum delay in milliseconds
 * @param {number} [max=config.timing.actionDelay.max] - Maximum delay in milliseconds
 * @returns {number} Random delay in milliseconds
 */
function getRandomDelay(min = config.timing.actionDelay.min, max = config.timing.actionDelay.max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Wait a random amount of time to mimic human behavior
 * @async
 * @param {Object} page - Puppeteer page object
 * @param {number} [min=config.timing.actionDelay.min] - Minimum delay in milliseconds
 * @param {number} [max=config.timing.actionDelay.max] - Maximum delay in milliseconds
 * @returns {Promise<number>} The actual delay used
 */
async function waitRandomTime(page, min, max) {
  const delay = getRandomDelay(min, max);
  await new Promise(resolve => setTimeout(resolve, delay));
  return delay;
}

/**
 * Perform a human-like scroll on the page
 * @async
 * @param {Object} page - Puppeteer page object
 * @param {number} [scrollDistance=800] - How far to scroll in pixels
 * @param {number} [scrollSteps=10] - Number of steps to break the scroll into
 * @returns {Promise<void>}
 */
async function humanScroll(page, scrollDistance = 800, scrollSteps = 10) {
  const scrollStep = Math.floor(scrollDistance / scrollSteps);
  
  for (let i = 0; i < scrollSteps; i++) {
    await page.evaluate((step) => {
      window.scrollBy(0, step);
    }, scrollStep);
    
    // Add a small random delay between scroll steps
    await new Promise(resolve => setTimeout(resolve, getRandomDelay(100, 300)));
  }
}

/**
 * Handle potential YouTube popups and dialogs
 * @async
 * @param {Object} page - Puppeteer page object
 * @returns {Promise<boolean>} True if popups were handled
 */
async function handlePopups(page) {
  try {
    // Check for and close cookie consent dialog
    const cookieConsentExists = await page.evaluate(() => {
      const cookieDialog = document.querySelector('.ytd-consent-bump-v2-lightbox');
      if (cookieDialog) {
        const acceptButton = document.querySelector('.ytd-consent-bump-v2-lightbox .ytd-consent-bump-v2-lightbox');
        if (acceptButton) {
          acceptButton.click();
          return true;
        }
      }
      return false;
    });
    
    // Check for and close YouTube Premium promo
    const premiumPromoExists = await page.evaluate(() => {
      const promoDialog = document.querySelector('.ytd-mealbar-promo-renderer');
      if (promoDialog) {
        const dismissButton = document.querySelector('.ytd-mealbar-promo-renderer .yt-button-renderer');
        if (dismissButton) {
          dismissButton.click();
          return true;
        }
      }
      return false;
    });
    
    return cookieConsentExists || premiumPromoExists;
  } catch (error) {
    console.error(`Error handling popups: ${error.message}`);
    return false;
  }
}

/**
 * Generate a timestamp string for logging
 * @returns {string} Formatted timestamp
 */
function getTimestamp() {
  return new Date().toISOString();
}

/**
 * Safely extract text from a DOM element
 * @async
 * @param {Object} page - Puppeteer page object
 * @param {string} selector - CSS selector for the element
 * @param {string} [defaultValue=''] - Default value if text extraction fails
 * @returns {Promise<string>} Extracted text or default value
 */
async function extractText(page, selector, defaultValue = '') {
  try {
    return await page.evaluate((sel) => {
      const element = document.querySelector(sel);
      return element ? element.textContent.trim() : '';
    }, selector);
  } catch (error) {
    console.error(`Error extracting text from ${selector}: ${error.message}`);
    return defaultValue;
  }
}

/**
 * Safely click on an element with retry capability
 * @async
 * @param {Object} page - Puppeteer page object
 * @param {string} selector - CSS selector to click
 * @param {number} [retries=3] - Number of retries if click fails
 * @param {number} [delay=500] - Delay between retries in milliseconds
 * @returns {Promise<boolean>} True if click was successful
 */
async function safeClick(page, selector, retries = 3, delay = 500) {
  let attempts = 0;
  
  while (attempts < retries) {
    try {
      // Wait for the element to be visible
      await page.waitForSelector(selector, { visible: true, timeout: 5000 });
      
      // Click the element
      await page.click(selector);
      
      return true;
    } catch (error) {
      attempts++;
      console.log(`Click attempt ${attempts}/${retries} failed for ${selector}: ${error.message}`);
      
      if (attempts >= retries) {
        console.error(`Failed to click ${selector} after ${retries} attempts`);
        return false;
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  return false;
}

module.exports = {
  getRandomDelay,
  waitRandomTime,
  humanScroll,
  handlePopups,
  getTimestamp,
  extractText,
  safeClick
};
